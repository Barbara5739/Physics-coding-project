from __future__ import annotations
import matplotlib.pyplot as plt
from matplotlib import animation
import numpy as np
import math as math
from abc import ABC, abstractmethod


Ms = 2.0e30   # mass of sun in kg unit
Me = 5.972e24   # mass of earth in kg unit        
G = 6.67e-11
day= 24*3600
AU = 1.5e11 # earth sun distance


class Galaxy:
    G = 6.6743*10**-11
    def __init__(self, name, mass, start_x: float = 0, start_y: float = 0):
        self.name = name
        self.mass = mass
        self.x = start_x
        self.y = start_y
        
class Star(Galaxy):
    def get_location(self):
        return self.x, self.y
    def get_mass(self):
        return self.mass


class Planet(Galaxy): 
    def __init__ (self, name, Star: Star, mass, start_x: float, start_y: float, start_x_speed: float = 0, start_y_speed: float = 0  ):
        super().__init__(name, mass,start_x,start_y)
        self.refrence_x = Star.x
        self.refrence_y = Star.y
        self.refrence_mass = Star.mass
        self.vx = start_x_speed
        self.vy = start_y_speed
        self.x_positions = []
        self.y_positions = []

    @abstractmethod
    def get_location(self, time_interval):
        pass
    
     
    def set_refrence_Star(self, Star: Star):
          self.refrence_x = Star.x
          self.refrence_y = Star.y
          self.refrence_mass = Star.mass


  

class Planet_physical_orbit(Planet):
    def get_location( self,time_interval ) :
        ###Physical function for orbit
        r = (((self.x-self.refrence_x)**2 + (self.y-self.refrence_y)**2))**0.5 #distance between the planet and the star
        Fg = Galaxy.G*(self.refrence_mass*self.mass)/r**2 #gravitational force
        
        ax = -Fg * (self.x-self.refrence_x) / r / self.mass
        self.vx = self.vx + ax    * time_interval
        self.x = self.x + self.vx * time_interval
        self.x_positions.append(self.x.real)

        ay = -Fg * (self.y-self.refrence_y) / r / self.mass
        self.vy = self.vy + ay    * time_interval 
        self.y = self.y + self.vy * time_interval
        self.y_positions.append(self.y.real)
        
        return self.x,self.y,self.x_positions,self.y_positions
    


class Planet_manager:
    @staticmethod
    def create_planet_circular_orbit( name, Star: Star, mass, start_x: float, start_y: float, d =9):
          ### Mathematical fuction for orbit
          reference_y = start_y
          if reference_y == 0:
              reference_y = 1
         
          r_constant = (((start_x - Star.x)**2 + (start_y -Star.y)**2))**0.5 #distance between the planet and the star

          vx, vy = Planet_manager.get_needed_speed( r_constant, start_x, start_y, Star.mass, Star.x, reference_y)
          Planet = Planet_manager.create_planet_physical_orbit(name, Star, mass, start_x, start_y, vx, vy)
          return Planet
    
    @staticmethod
    def create_planet_physical_orbit ( name, Star: Star, mass, start_x: float, start_y: float, start_x_speed: float = 0, start_y_speed: float = 0  ):
         Planet = Planet_physical_orbit(name, Star, mass, start_x, start_y, start_x_speed , start_y_speed)
         Planet.set_refrence_Star(Star)
         return Planet

    @staticmethod
    def get_needed_speed( radius, x , y, reference_mass, reference_x, reference_y):
        
        omega = math.sqrt((Galaxy.G * reference_mass)/radius**3)
        vt = radius * omega
        theta = np.degrees(np.arctan2((y - reference_y), (x - reference_x)))
        vx = np.sin(theta) * vt
        vy = np.cos(theta)* vt
        return vx, vy


class Alien(Planet):
    # def __init__(self, Star: Star, name, mass, xa, ya, vxa, vya):
        # self.x = xa
        # self.y = ya
        # self.vx = vxa
        # self.vy = vya
        # self.name = name
      def get_location(self, time_interval): 

    
class Moon(Planet):
    # def __init__(self, Planet: Planet, mass, x, y, vx, vy):
        # self.mass = mass
        # self.x = x
        # self.y = y
        # self.vx = vx
        # self.vy = vy
      def get_location(self, time_interval):
          return super().get_location(time_interval)

###visualization of the planet movement
sun = Star("Sun", Ms, sx, sy)
sx==0
sy==0
planet = Planet("Earth", sun, Me, AU, 0)

###Creates the Solar System
fig, ax = plt.subplots(figsize=(10,10))
ax.set_aspect('equal')
ax.grid()
ax.axis('equal')
ax.set_xlim(-3*AU,3*AU)
ax.set_ylim(-3*AU,3*AU)
plt.xlabel("X")
plt.ylabel("Y")
plt.title("Solar System")
###Sun initial
point_s,    = ax.plot([sx], [sy], marker="o", markersize=7, markeredgecolor="yellow", markerfacecolor="yellow")
text_s      = ax.text(sx,sy,'Sun')
###Planet initial
line_p,     = ax.plot([],[],'-g',lw=1,c='blue')
point_p,    = ax.plot([AU], [0], marker="o", markersize=4, markeredgecolor="blue", markerfacecolor="blue")
text_e      = ax.text(AU,0,'Planet')
"""
###Alien initial
line_a,     = ax.plot([],[],'-g',lw=1)
point_a,    = ax.plot([1.666*AU], [0], marker="o", markersize=3, markeredgecolor="red", markerfacecolor="red")
text_a      = ax.text(1.666*AU,0,'Alien')
###Moon initial
line_m,     = ax.plot([],[],'-g',lw=1)
point_m,    = ax.plot([2*AU], [0], marker="o", markersize=2, markeredgecolor="black", markerfacecolor="black")
text_m      = ax.text(2*AU,0,'Moon')"""

sxdata,sydata = [],[]                   # sun track
pxdata,pydata = [],[]                   # earth track
'''axdata,aydata = [],[]                   # alien track
   mxdata,mydata = [],[]            #moon track'''
#Animation:
def animate(i):
    time_interval = day  # time interval in seconds
    # Sun position update
    sx, sy = sun.get_location()
    sxdata.append(sx)
    sydata.append(sy)
    point_s.set_data(sx, sy)
    text_s.set_position((sx, sy))
    
    # Planet position update
    px, py, x_positions, y_positions = planet.get_location(time_interval)
    point_p.set_data(px, py)
    text_e.set_position((px, py))
    line_p.set_data(x_positions, y_positions)
    
  

anim = animation.FuncAnimation(fig,func=animate,frames=len(pxdata),interval=1,blit=True)           

plt.show()
