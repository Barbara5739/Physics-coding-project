from __future__ import annotations
import matplotlib.pyplot as plt
from matplotlib import animation
import numpy as np
import math as math
from abc import ABC, abstractmethod


Ms = 2.0e30   # mass of sun in kg unit
Me = 5.972e24   # mass of earth in kg unit        
G = 6.67e-11
day= 24*3600
AU = 1.5e11 # earth sun distance


class Galaxy:
    G = 6.6743*10**-11
    def __init__(self, name, mass, start_x: float = 0, start_y: float = 0):
        self.name = name
        self.mass = mass
        self.x = start_x
        self.y = start_y
        
class Star(Galaxy):
    def get_location(self):
        return self.x, self.y
    def get_mass(self):
        return self.mass


class Planet(Galaxy): 
    def __init__ (self, name, Star: Star, mass, px: float, py: float, start_xp_speed: float = 0, start_yp_speed: float = 0  ):
        super().__init__(name, mass, px, py)
        self.refrence_x = Star.x
        self.refrence_y = Star.y
        self.refrence_mass = Star.mass
        self.vx = start_xp_speed
        self.vy = start_yp_speed
        self.x_positions = []
        self.y_positions = []

    @abstractmethod
    def get_location(self, time_interval):
        pass
    
     
    def set_refrence_Star(self, Star: Star):
          self.refrence_x = Star.x
          self.refrence_y = Star.y
          self.refrence_mass = Star.mass


class Planet_physical_orbit(Planet):
    def get_location(self, time_interval) :
        ###Physical function for orbit
        r = (((self.x-self.refrence_x)**2 + (self.y-self.refrence_y)**2))**0.5 #distance between the planet and the star
        Fg = Galaxy.G*(self.refrence_mass*self.mass)/r**2 #gravitational force
        
        ax = -Fg * (self.x-self.refrence_x) / r / self.mass
        self.vx = self.vx + ax    * time_interval
        self.x = self.x + self.vx * time_interval
        self.x_positions.append(self.x.real)

        ay = -Fg * (self.y-self.refrence_y) / r / self.mass
        self.vy = self.vy + ay    * time_interval 
        self.y = self.y + self.vy * time_interval
        self.y_positions.append(self.y.real)
        

        return self.x,self.y,self.x_positions,self.y_positions
        
    
class Planet_manager:
    @staticmethod
    def create_planet_circular_orbit(name, Star: Star, mass, start_x: float, start_y: float, d =9):
          ### Mathematical fuction for orbit
          reference_y = start_y
          if reference_y == 0:
              reference_y = 1
         
          r_constant = (((start_x - Star.x)**2 + (start_y -Star.y)**2))**0.5 #distance between the planet and the star

          vx, vy = Planet_manager.get_needed_speed( r_constant, start_x, start_y, Star.mass, Star.x, reference_y)
          Planet = Planet_manager.create_planet_physical_orbit(name, Star, mass, start_x, start_y, vx, vy)
          return Planet
    
    @staticmethod
    def create_planet_physical_orbit ( name, Star: Star, mass, start_x: float, start_y: float, start_x_speed: float = 0, start_y_speed: float = 0  ):
         Planet = Planet_physical_orbit(name, Star, mass, start_x, start_y, start_x_speed , start_y_speed)
         Planet.set_refrence_Star(Star)
         return Planet

    @staticmethod
    def get_needed_speed( radius, x , y, reference_mass, reference_x, reference_y):
        
        omega = math.sqrt((Galaxy.G * reference_mass)/radius**3)
        vt = radius * omega
        theta = np.degrees(np.arctan2((y - reference_y), (x - reference_x)))
        vx = np.sin(theta) * vt
        vy = np.cos(theta)* vt
        return vx, vy

class Alien(Planet):
    # def __init__(self, Star: Star, name, mass, xa, ya, vxa, vya):
        # self.x = xa
        # self.y = ya
        # self.vx = vxa
        # self.vy = vya
        # self.name = name
      def get_location(self, time_interval): 

    
class Moon(Planet):
    # def __init__(self, Planet: Planet, mass, x, y, vx, vy):
        # self.mass = mass
        # self.x = x
        # self.y = y
        # self.vx = vx
        # self.vy = vy
      def get_location(self, time_interval):
          return super().get_location(time_interval)

###visualization of the planet movement

sx=0
sy=0
sun = Star("Sun", Ms, sx, sy)

px=AU
py=0
planet = Planet_manager.create_planet_circular_orbit("Earth", sun, Me, px, py)

###Creates the Solar System
fig, ax = plt.subplots(figsize=(10,10))
ax.set_aspect('equal')
ax.grid()
ax.axis('equal')
ax.set_xlim(-3*AU,3*AU)
ax.set_ylim(-3*AU,3*AU)
plt.xlabel("X")
plt.ylabel("Y")
plt.title("Solar System")

#initial of the objects

text_s   = ax.text(sx, sy, "Sun")
point_s, = ax.plot([sx], [sy], marker="o", markersize=7, color="yellow")

line_p,  = ax.plot([], [], lw=1, color='blue')
point_p, = ax.plot([px], [py], marker="o", markersize=4, color="blue")
text_p   = ax.text(px, py, "Planet")

def init():
    line_p.set_data([], [])
    point_p.set_data([], [])
    return line_p, point_p, point_s, text_p, text_s


sxdata,sydata = [],[]                   # sun track
pxdata,pydata = [],[]                   # earth track
'''axdata,aydata = [],[]                # alien track
   mxdata,mydata = [],[]                #moon track'''


#Animation
def animate(i):
    dt = day  # seconds per step

    # Update planet physics
    x, y = planet.get_location(time_interval)


    # Update line (orbit trail)
    line_p.set_data(xp_position, yp_position)

    # Update planet point
    point_p.set_data(xp_positions[i], yp_positions[i])
    text_p.set_position(xp_positions[i], yp_positions[i])

    return line_p, point_p, point_s, text_p, text_s
anim = animation.FuncAnimation( fig, animate, init_func=init, frames=2000, interval=20, blit=True)
    


plt.show()
