from __future__ import annotations
import matplotlib.pyplot as plt
from matplotlib import animation
import numpy as np
import math as math
from abc import ABC, abstractmethod 
from IPython.display import HTML

Ms = 2.0e30   # mass of sun in kg unit
Me = 5.972e24   # mass of earth in kg unit        
G = 6.67e-11
day= 24*3600
AU = 1.5e11 # earth sun distance

class Galaxy:             # The upper most class of the galaxy system
    G = 6.6743*10**-11    # G is the universal gravitation constant that will be used througout the simulation, since this number is equal everywhere in the universe / galaxy, it belongs to this class.
    def __init__(self, name, mass, start_x: float = 0, start_y: float = 0):    # these are propperties that every object "spawned" inside our galaxy has, therefore they are already defined in the galaxy class to avoid repetition of code
        # super init
        self.name = name
        self.mass = mass
        self.x = start_x
        self.y = start_y
        
class Star(Galaxy):        # returns the value's of the star(s) in the galaxy system to use in plots
    #  Star class, static object in the galaxy like the sun
    def get_location(self):
        # get star's location
        return self.x, self.y
    def get_mass(self):
        # get star's mass
        return self.mass

class Moving_Object(Galaxy): # Class for moving objects in the galaxy like planets, komets, ufo's etc
    def __init__ (self, name, Star: Star, mass, start_x: float, start_y: float, start_x_speed: float = 0, start_y_speed: float = 0  ):
        super().__init__(name, mass,start_x,start_y)
        #  set moving object own attributes
        self.reference_x, self.reference_y = Star.get_location()
        self.reference_mass = Star.get_mass()
        self.reference_name = Star.name
        self.vx = start_x_speed
        self.vy = start_y_speed
        self.x_positions = []
        self.y_positions = []

    def __str__(self) -> str:
        #  printable definition of the moving object
        return f"Planet: {self.name} mass: {self.mass} orbiting around {self.reference_name}"
    
    @abstractmethod
    def get_location(self, time_interval):
        # get current location of the planet. Redefine in the subclass
        pass
    
    def set_reference_Star(self, Star: Star):
        #   set data of reference star, this is the star around which the planets circulate
          self.reference_x, self.reference_y = Star.get_location( )
          self.reference_mass = Star.get_mass()


  
class Planet_physical_orbit(Moving_Object):
    def get_location(self, time_interval) :
        ###Physical function for orbit
        r = (((self.x-self.reference_x)**2 + (self.y-self.reference_y)**2))**0.5 #distance between the planet and the star
        Fg = Galaxy.G*(self.reference_mass*self.mass)/r**2 #gravitational force
        
        # Calculate the current x position in time
        ax = -Fg * (self.x-self.reference_x) / r / self.mass
        self.vx = self.vx + ax    * time_interval
        self.x = self.x + self.vx * time_interval
        # Store the x postion in a list
        self.x_positions.append(self.x.real)

        # Calculate the current y position in time
        ay = -Fg * (self.y-self.reference_y) / r / self.mass
        self.vy = self.vy + ay    * time_interval 
        self.y = self.y + self.vy * time_interval
         # Store the y postion in a list
        self.y_positions.append(self.y.real)
        
        return self.x_positions,self.y_positions
    

class Object_manager:
    # Class to instantiate the moving objects. 
    @staticmethod
    def create_planet_circular_orbit(name, Star: Star, mass, start_x: float, start_y: float, d =9):
          ### Mathematical fuction for orbit
                
          r_constant = (((start_x - Star.x)**2 + (start_y -Star.y)**2))**0.5 #distance between the planet and the star
          #get needed speed to achieve circular orbit with pyshics calculation
          vx, vy = Object_manager.get_needed_speed( r_constant, start_x, start_y, Star.mass, Star.x, Star.y) 
          # Create Physical planet for the asked distance to the star
          Planet = Object_manager.create_planet_physical_orbit(name, Star, mass, start_x, start_y, vx, vy)
          return Planet
    
    @staticmethod
    def create_planet_physical_orbit ( name, Star: Star, mass, start_x: float, start_y: float, start_x_speed: float = 0, start_y_speed: float = 0  ):
         # create Physics calculated orbit by speed mass planet, mass star and G force 
         Planet = Planet_physical_orbit(name, Star, mass, start_x, start_y, start_x_speed , start_y_speed)
         return Planet

    @staticmethod
    def get_needed_speed( radius, x , y, reference_mass, reference_x, reference_y):
        # Calculate speed for needed radius
        omega = math.sqrt((Galaxy.G * reference_mass)/radius**3) #calculate angular velocity
        vt = radius * omega #linear tangential velocity
        theta = np.degrees(np.arctan2((y - reference_y), (x - reference_x))) # signed angle 
        vx = np.sin(theta) * vt   # Get x speed
        vy = np.cos(theta)* vt    # Get y speed
        return vx, vy


class Alien(Moving_Object):
    # def __init__(self, Star: Star, name, mass, xa, ya, vxa, vya):
        # self.x = xa
        # self.y = ya
        # self.vx = vxa
        # self.vy = vya
        # self.name = name
      def get_location(self, time_interval): 
        pass
    
class Moon(Moving_Object):
    # def __init__(self, Planet: Planet, mass, x, y, vx, vy):
        # self.mass = mass
        # self.x = x
        # self.y = y
        # self.vx = vx
        # self.vy = vy
      def get_location(self, time_interval):
          return super().get_location(time_interval)


#Seting up the objects
#Sun initial
sx=0
sy=0
sun = Star("Sun", Ms, sx, sy)
#Planet initial
px=AU
py=0
vp=math.sqrt(G*Ms/AU) # tangential speed for circular orbit
planet = Planet_physical_orbit("Earth", sun, Me, px, py, 0, vp)
#Alien initial
xa=3*AU
ya=0
alien = Alien("Alien", sun, 1000, xa, ya, 0, 2000)
#Moon initial
mx=2*AU
my=0
moon = Moon("Moon", planet, 1000, mx, my, 0)


###visualization of the planet movement
###Creates the Solar System
fig, ax = plt.subplots(figsize=(10,10))
ax.set_aspect('equal')
ax.grid()
ax.axis('equal')
ax.set_xlim(-5*AU,5*AU)
ax.set_ylim(-5*AU,5*AU)
plt.xlabel("X")
plt.ylabel("Y")
plt.title("Solar System")

#initial of the objects
text_s   = ax.text(sx, sy, "Sun")
point_s, = ax.plot([sx], [sy], marker="o", markersize=11, color="yellow")

line_p,  = ax.plot([], [], lw=1, color='blue')
point_p, = ax.plot([px], [py], marker="o", markersize=5, color="blue")
text_p   = ax.text(px, py, "Planet")

line_a,  = ax.plot([], [], lw=1, color='red')
point_a, = ax.plot([xa], [ya], marker="o", markersize=4, color="red")
text_a   = ax.text(xa, ya, "Alien")

line_m,  = ax.plot([], [], lw=1, color='grey')
point_m, = ax.plot([mx], [my], marker="o", markersize=4, color="grey")
text_m   = ax.text(mx, my, "Moon")

def init():
    line_p.set_data([], [])
    point_p.set_data([], [])

    line_a.set_data([], [])
    point_a.set_data([], [])

    line_m.set_data([], [])
    point_m.set_data([], [])
    return line_p, point_p, point_s, text_p, text_s
#Animation
def animate(i):
    dt = day  # seconds per step
    planet.get_location(dt)
    '''alien.get_location(dt)
    moon.get_location(dt)'''
    # Update line (orbit trail)
    line_p.set_data([planet.x_positions], [planet.y_positions])
    xp_new, yp_new = planet.x_positions[-1], planet.y_positions[-1]
    point_p.set_data([xp_new], [yp_new])
    text_p.set_position((xp_new, yp_new))
    '''
    line_a.set_data([alien_x_new], [alien_y_new])
    point_a.set_data(alien_x_new, alien_y_new)
    text_a.set_position(alien_x_new, alien_y_new)

    line_m.set_data([moon_x_new], [moon_y_new])
    point_m.set_data(moon_x_new, moon_y_new)
    text_m.set_position(moon_x_new, moon_y_new)'''

    return line_p, point_p, point_s, text_p, text_s
anim = animation.FuncAnimation(fig, animate, init_func=init, frames=200, interval=20, blit=False)

HTML(anim.to_jshtml())
