from __future__ import annotations
import matplotlib.pyplot as plt
from matplotlib import animation
import numpy as np
import math as math
from abc import ABC, abstractmethod 
from IPython.display import HTML
import pandas as pd

Ms = 2.0e30   # mass of sun in kg unit
Me = 5.972e24   # mass of earth in kg unit        
day= 24*3600
G = 6.6743*10**-11
AU = 1.5e11 # earth sun distance

class Galaxy:             # The upper most class of the galaxy system
    G = 6.6743*10**-11    # G is the universal gravitation constant that will be used througout the simulation, since this number is equal everywhere in the universe / galaxy, it belongs to this class.
    def __init__(self, name, mass, start_x: float = 0, start_y: float = 0):    # these are propperties that every object "spawned" inside our galaxy has, therefore they are already defined in the galaxy class to avoid repetition of code
        # super init
        self.name = name
        self.mass = mass
        self.x = start_x
        self.y = start_y
        
class Star(Galaxy):        # returns the value's of the star(s) in the galaxy system to use in plots
    #  Star class, static object in the galaxy like the sun
    def get_location(self):
        # get star's location
        return self.x, self.y
    def get_mass(self):
        # get star's mass
        return self.mass

class Moving_Object(Galaxy): # Class for moving objects in the galaxy like planets, comets, ufo's etc
    def __init__ (self, name, Star: Star, mass, start_x: float, start_y: float, start_x_speed: float = 0, start_y_speed: float = 0  ):
        super().__init__(name, mass,start_x,start_y)
        #  set moving object own attributes
        self.reference_x, self.reference_y = Star.get_location()
        self.reference_mass = Star.get_mass()
        self.reference_name = Star.name
        self.vx = start_x_speed
        self.vy = start_y_speed
        self.x_positions = []
        self.y_positions = []

    def __str__(self) -> str:
        #  printable definition of the moving object
        return f"Planet: {self.name} mass: {self.mass} orbiting around {self.reference_name}"
    
    @abstractmethod
    def get_location(self, time_interval):
        # get current location of the planet. Redefine in the subclass
        pass
    
    def set_reference_Star(self, Star: Star):
        #   set data of reference star, this is the star around which the planets circulate
          self.reference_x, self.reference_y = Star.get_location( )
          self.reference_mass = Star.get_mass()


  
class Planet_physical_orbit(Moving_Object):
    def get_location(self, time_interval) :
        ###Physical function for orbit
        r = (((self.x-self.reference_x)**2 + (self.y-self.reference_y)**2))**0.5 #distance between the planet and the star
        Fg = Galaxy.G*(self.reference_mass*self.mass)/r**2 #gravitational force
        
        # Calculate the current x position in time
        ax = -Fg * (self.x-self.reference_x) / r / self.mass
        self.vx = self.vx + ax    * time_interval
        self.x = self.x + self.vx * time_interval
        # Store the x postion in a list
        self.x_positions.append(self.x.real)

        # Calculate the current y position in time
        ay = -Fg * (self.y-self.reference_y) / r / self.mass
        self.vy = self.vy + ay    * time_interval 
        self.y = self.y + self.vy * time_interval
         # Store the y postion in a list
        self.y_positions.append(self.y.real)
        
        return self.x_positions,self.y_positions
    

class Object_manager:
    # Class to instantiate the moving objects. 
    @staticmethod
    def create_planet_circular_orbit(name, Star: Star, mass, start_x: float, start_y: float, d =9):
          ### Mathematical fuction for orbit
                
          r_constant = (((start_x - Star.x)**2 + (start_y -Star.y)**2))**0.5 #distance between the planet and the star
          #get needed speed to achieve circular orbit with pyshics calculation
          vx, vy = Object_manager.get_needed_speed( r_constant, start_x, start_y, Star.mass, Star.x, Star.y) 
          # Create Physical planet for the asked distance to the star
          Planet = Object_manager.create_planet_physical_orbit(name, Star, mass, start_x, start_y, vx, vy)
          return Planet
    
    @staticmethod
    def create_planet_physical_orbit ( name, Star: Star, mass, start_x: float, start_y: float, start_x_speed: float = 0, start_y_speed: float = 0  ):
         # create Physics calculated orbit by speed mass planet, mass star and G force 
         Planet = Planet_physical_orbit(name, Star, mass, start_x, start_y, start_x_speed , start_y_speed)
         return Planet

    @staticmethod
    def get_needed_speed( radius, x , y, reference_mass, reference_x, reference_y):
        # Calculate speed for needed radius
        omega = math.sqrt((Galaxy.G * reference_mass)/radius**3) #calculate angular velocity
        vt = radius * omega #linear tangential velocity
        theta = np.degrees(np.arctan2((y - reference_y), (x - reference_x))) # signed angle 
        vx = np.sin(theta) * vt   # Get x speed
        vy = np.cos(theta)* vt    # Get y speed
        return vx, vy

class alien_visitor():
    def __init__(self, mass_a, x_initial_a, y_initial_a, perihelion_distance_a, orbital_eccentricity_a):
    
      
        self.mass_a = mass_a
        # single starting position
        self.x0 = x_initial_a
        self.y0 = y_initial_a
        # orbit lists
        self.x_positions = []
        self.y_positions = []
        self.perihelion_distance = perihelion_distance_a
        self.orbital_eccentricity = orbital_eccentricity_a

    def _define_initial_position_alien(self):  
        self.x_initial_a = []
        self.y_initial_a = []
        return self.x_initial_a, self.y_initial_a
    def plot_alien_visitor_orbit(self):

        self.x_positions = []
        self.y_positions = []

        for x in np.linspace(-3*AU, 3*AU, 400):
            y = self.orbital_eccentricity * (x / AU)**2 * AU - self.perihelion_distance * AU - 3 * AU
            self.x_positions.append(x)
            self.y_positions.append(y)
    

#Seting up the objects(This part has to be read from another file?)
Solar = pd.read_excel('Solar.xlsx')
#Sun initial
sx = Solar.iloc[0, 2]
sy= Solar.iloc[0, 3]
vs = Solar.iloc[0,4]
sun = Star("Sun", Ms, sx, sy)
#Planet initial
px=Solar.iloc[1,2]
py=Solar.iloc[1,3]
vp=Solar.iloc[1,4] # tangential speed for circular orbit
planet = Planet_physical_orbit("Earth", sun, Me, px, py, 0, vp)
#Planet2 initial
px2=1.524*AU
py2=0
vm=math.sqrt(G*Ms/px2) # tangential speed for circular orbit
planet2= Planet_physical_orbit("Mars", sun, 6.39e23, px2, py2, 0, vm)
#Alien initial
xa=Solar.iloc[4,2]
ya=Solar.iloc[4,3]
alien = alien_visitor(1000, xa, ya, -2, 1.5 )
alien.plot_alien_visitor_orbit()



###visualization of the planet movement
###Creates the Solar System
fig, ax = plt.subplots(figsize=(6,6))
ax.set_aspect('equal')
ax.grid()
ax.axis('equal')
ax.set_xlim(-5*AU,5*AU)
ax.set_ylim(-5*AU,5*AU)
plt.xlabel("X")
plt.ylabel("Y")
plt.title("Solar System")

#initial conditions of the objects
text_s   = ax.text(sx, sy, "Sun")
point_s, = ax.plot([sx], [sy], marker="o", markersize=11, color="yellow")

line_p,  = ax.plot([], [], lw=1, color='green')
point_p, = ax.plot([px], [py], marker="o", markersize=5, color="blue")
text_p   = ax.text(px, py, "Planet")

line_a,  = ax.plot([], [], lw=1, color='green')
point_a, = ax.plot([xa], [ya], marker="o", markersize=4, color="red")
text_a   = ax.text(xa, ya, "Alien")

line_p2,  = ax.plot([], [], lw=1, color='green')
point_p2, = ax.plot([px2], [py2], marker="o", markersize=4, color="orange")
text_p2   = ax.text(px2, py2, "Mars")    

def init():
    line_p.set_data([], [])
    point_p.set_data([], [])

    line_a.set_data([], [])
    point_a.set_data([], [])

    line_p2.set_data([], [])
    point_p2.set_data([], [])        
    return line_p, point_p, point_s, text_p, text_s, point_a, text_a, point_p2, text_p2


#Animation
def animate(i):
    dt = day  # seconds per step
    planet.get_location(dt)
    planet2.get_location(dt)
    # Animation for planet 
    line_p.set_data(planet.x_positions, planet.y_positions)
    xp_new, yp_new = planet.x_positions[-1], planet.y_positions[-1]
    point_p.set_data([xp_new], [yp_new])
    text_p.set_position((xp_new, yp_new))
    #Animation for mars
    line_p2.set_data(planet2.x_positions, planet2.y_positions)
    xm_new, ym_new = planet2.x_positions[-1], planet2.y_positions[-1]
    point_p2.set_data([xm_new], [ym_new])
    text_p2.set_position((xm_new, ym_new))
    #Animation for alien
    xa_new, ya_new = alien.x_positions[i], alien.y_positions[i]
    line_a.set_data(alien.x_positions[:i+1], alien.y_positions[:i+1])
    point_a.set_data([xa_new], [ya_new])
    text_a.set_position((xa_new, ya_new))
    

    return line_p, point_p, point_s, text_p, text_s, point_a, text_a, line_p2, point_p2, text_p2
anim = animation.FuncAnimation(fig, animate, init_func=init,frames=400, interval=50, blit=False)


plt.show()
