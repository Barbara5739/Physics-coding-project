from __future__ import annotations
import matplotlib.pyplot as plt
from matplotlib import animation
import numpy as np
import math as math
from abc import ABC, abstractmethod 


Ms = 2.0e30   # mass of sun in kg unit
Me = 5.972e24   # mass of earth in kg unit        
G = 6.67e-11
day= 24*3600
AU = 1.5e11 # earth sun distance

class Galaxy:             # The upper most class of the galaxy system
    G = 6.6743*10**-11    # G is the universal gravitation constant that will be used througout the simulation, since this number is equal everywhere in the universe / galaxy, it belongs to this class.
    def __init__(self, name, mass, start_x: float = 0, start_y: float = 0):    # these are propperties that every object "spawned" inside our galaxy has, therefore they are already defined in the galaxy class to avoid repetition of code
        # super init
        self.name = name
        self.mass = mass
        self.x = start_x
        self.y = start_y
        
class Star(Galaxy):        # returns the value's of the star(s) in the galaxy system to use in plots
    #  Star class, static object in the galaxy like the sun
    def get_location(self):
        # get star's location
        return self.x, self.y
    def get_mass(self):
        # get star's mass
        return self.mass

class Moving_Object(Galaxy): # Class for moving objects in the galaxy like planets, komets, ufo's etc
    def __init__ (self, name, Star: Star, mass, start_x: float, start_y: float, start_x_speed: float = 0, start_y_speed: float = 0  ):
        super().__init__(name, mass,start_x,start_y)
        #  set moving object own attributes
        self.reference_x, self.reference_y = Star.get_location()
        self.reference_mass = Star.get_mass()
        self.reference_name = Star.name
        self.vx = start_x_speed
        self.vy = start_y_speed
        self.x_positions = []
        self.y_positions = []

    def __str__(self) -> str:
        #  printable definition of the moving object
        return f"Planet: {self.name} mass: {self.mass} orbiting around {self.reference_name}"
    

    @abstractmethod
    def get_location(self, time_interval):
        # get current location of the planet. Redefine in the subclass
        pass
    
     
    def set_reference_Star(self, Star: Star):
        #   set data of reference star, this is the star around which the planets circulate
          self.reference_x, self.reference_y = Star.get_location( )
          self.reference_mass = Star.get_mass()


  

class Planet_physical_orbit(Moving_Object):
    def get_location(self, time_interval) :
        ###Physical function for orbit
        r = (((self.x-self.reference_x)**2 + (self.y-self.reference_y)**2))**0.5 #distance between the planet and the star
        Fg = Galaxy.G*(self.reference_mass*self.mass)/r**2 #gravitational force
        
        # Calculate the current x position in time
        ax = -Fg * (self.x-self.reference_x) / r / self.mass
        self.vx = self.vx + ax    * time_interval
        self.x = self.x + self.vx * time_interval
        # Store the x postion in a list
        self.x_positions.append(self.x.real)

        # Calculate the current y position in time
        ay = -Fg * (self.y-self.reference_y) / r / self.mass
        self.vy = self.vy + ay    * time_interval 
        self.y = self.y + self.vy * time_interval
         # Store the y postion in a list
        self.y_positions.append(self.y.real)
        
        return self.x,self.y,self.x_positions,self.y_positions
    


class Object_manager:
    # Class to instantiate the moving objects. 
    @staticmethod
    def create_planet_circular_orbit(name, Star: Star, mass, start_x: float, start_y: float, d =9):
          ### Mathematical fuction for orbit
                
          r_constant = (((start_x - Star.x)**2 + (start_y -Star.y)**2))**0.5 #distance between the planet and the star
          #get needed speed to achieve circular orbit with pyshics calculation
          vx, vy = Object_manager.get_needed_speed( r_constant, start_x, start_y, Star.mass, Star.x, Star.y) 
          # Create Physical planet for the asked distance to the star
          Planet = Object_manager.create_planet_physical_orbit(name, Star, mass, start_x, start_y, vx, vy)
          return Planet
    
    @staticmethod
    def create_planet_physical_orbit ( name, Star: Star, mass, start_x: float, start_y: float, start_x_speed: float = 0, start_y_speed: float = 0  ):
         # create Physics calculated orbit by speed mass planet, mass star and G force 
         Planet = Planet_physical_orbit(name, Star, mass, start_x, start_y, start_x_speed , start_y_speed)
         Planet.set_reference_Star(Star) # set star around which the planet makes it orbit
         return Planet

    @staticmethod
    def get_needed_speed( radius, x , y, reference_mass, reference_x, reference_y):
        # Calculate speed for needed radius
        omega = math.sqrt((Galaxy.G * reference_mass)/radius**3) #calculate angular velocity
        vt = radius * omega #linear tangential velocity
        theta = np.degrees(np.arctan2((y - reference_y), (x - reference_x))) # signed angle 
        vx = np.sin(theta) * vt   # Get x speed
        vy = np.cos(theta)* vt    # Get y speed
        return vx, vy


class Alien(Moving_Object):
    # def __init__(self, Star: Star, name, mass, xa, ya, vxa, vya):
        # self.x = xa
        # self.y = ya
        # self.vx = vxa
        # self.vy = vya
        # self.name = name
      def get_location(self, time_interval): 
        pass
    
class Moon(Moving_Object):
    # def __init__(self, Planet: Planet, mass, x, y, vx, vy):
        # self.mass = mass
        # self.x = x
        # self.y = y
        # self.vx = vx
        # self.vy = vy
      def get_location(self, time_interval):
          return super().get_location(time_interval)


###visualization of the planet movement
#Sun initial
sx=0
sy=0
sun = Star("Sun", Ms, sx, sy)
#Planet initial
px=AU
py=0
planet = Planet_physical_orbit("Earth", sun, Me, px, py, 0, 1000)
#Alien initial
ax=3*AU
ay=0
alien = Alien("Alien", sun, 1000, ax, ay, 0, 2000)
#Moon initial
'''mx=get_location(Planet_physical_orbit)
my=
moon = Moon("Moon", planet, 1000, mx, my, 0, 3000)'''

###Creates the Solar System
fig, ax = plt.subplots(figsize=(10,10))
ax.set_aspect('equal')
ax.grid()
ax.axis('equal')
ax.set_xlim(-3*AU,3*AU)
ax.set_ylim(-3*AU,3*AU)
plt.xlabel("X")
plt.ylabel("Y")
plt.title("Solar System")

#initial of the objects
text_s   = ax.text(sx, sy, "Sun")
point_s, = ax.plot([sx], [sy], marker="o", markersize=11, color="yellow")

line_p,  = ax.plot([], [], lw=1, color='blue')
point_p, = ax.plot([px], [py], marker="o", markersize=4, color="blue")
text_p   = ax.text(px, py, "Planet")

line_a,  = ax.plot([], [], lw=1, color='red')
point_a, = ax.plot([px], [py], marker="o", markersize=4, color="red")
text_a   = ax.text(px, py, "Alien")

line_m,  = ax.plot([], [], lw=1, color='grey')
point_m, = ax.plot([px], [py], marker="o", markersize=4, color="grey")
text_m   = ax.text(px, py, "Moon")

def init():
    line_p.set_data([], [])
    point_p.set_data([], [])
    line_a.set_data([], [])
    point_a.set_data([], [])
    line_m.set_data([], [])
    point_m.set_data([], [])
    return line_p, point_p, line_a, point_a, line_m, point_m, point_s, text_p, text_a, text_m


sxdata,sydata = [Moving_Object.x_positions[0]],[Moving_Object.y_positions[0]]                   # sun track
pxdata,pydata = [Planet_physical_orbit.x_positions],[Planet_physical_orbit.y_positions]                   # earth track
axdata,aydata = [],[]                # alien track
mxdata,mydata = [],[]                #moon track


#Animation
def animate(i):
    dt = day  # seconds per step

    # Update line (orbit trail)
    line_p.set_data(Moving_Object.x_positions, Moving_Object.y_positions)

    # Update planet point
    point_p.set_data(Moving_Object.x_positions[i], Moving_Object.y_positions[i])
    text_p.set_position(Moving_Object.x_positions[i], Moving_Object.y_positions[i])

    return line_p, point_p, point_s, text_p, text_s
anim = animation.FuncAnimation( fig, animate, init_func=init, frames=2000, interval=20, blit=True)
    


plt.show()
